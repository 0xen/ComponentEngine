#version 460

#extension GL_KHR_shader_subgroup_ballot: enable

struct particle_system_instance{
	vec4 emitter_location;
	vec4 start_color;
	vec4 end_color;
	vec4 data;
};

layout(std430, set=0, binding=0) buffer particle_system_buffer {
  particle_system_instance particle_system_data;
};


struct particle_system_value_instance{
	vec4 start_position;
	vec4 velocity;

	// data.x = Start Life
	// data.y = Life
	// data.z = Scale
	vec4 data;
};

layout(std430, set=1, binding=0) buffer particle_system_value_buffer {
  particle_system_value_instance particle_system_value_data[];
};



struct particle_vertex_instance{
	vec4 vertex;
	vec4 color;
};

layout(std430, set=2, binding=0) buffer particle_vertex_buffer {
  particle_vertex_instance particle_vertex_data[];
};



void main(){
	uint ParticleIndex = gl_GlobalInvocationID.x;


	particle_system_value_data[ParticleIndex].data.y -= particle_system_data.data.x;

	vec4 position = particle_system_value_data[ParticleIndex].start_position;

	if(particle_system_value_data[ParticleIndex].data.y<0.0f)
	{
		// Reset but leave extra time data
		particle_system_value_data[ParticleIndex].data.y = particle_system_value_data[ParticleIndex].data.x;
	}
	else
	{

		vec4 distance_to_travel = particle_system_value_data[ParticleIndex].velocity * (particle_system_value_data[ParticleIndex].data.x - particle_system_value_data[ParticleIndex].data.y);
		position += distance_to_travel;
	}

	float rad = (120 * 3.14) / 180;


	particle_vertex_data[ParticleIndex * 3 + 0].vertex = -vec4(sin(rad * 0),cos(rad * 0),0.0f,0.0f);
	particle_vertex_data[ParticleIndex * 3 + 1].vertex = -vec4(sin(rad * 1),cos(rad * 1),0.0f,0.0f);
	particle_vertex_data[ParticleIndex * 3 + 2].vertex = -vec4(sin(rad * 2),cos(rad * 2),0.0f,0.0f);
	

	particle_vertex_data[ParticleIndex * 3 + 0].vertex.xy *= particle_system_value_data[ParticleIndex].data.z;
	particle_vertex_data[ParticleIndex * 3 + 1].vertex.xy *= particle_system_value_data[ParticleIndex].data.z;
	particle_vertex_data[ParticleIndex * 3 + 2].vertex.xy *= particle_system_value_data[ParticleIndex].data.z;


	particle_vertex_data[ParticleIndex * 3 + 0].vertex += position;
	particle_vertex_data[ParticleIndex * 3 + 1].vertex += position;
	particle_vertex_data[ParticleIndex * 3 + 2].vertex += position;

	vec4 color = mix(
		particle_system_data.end_color,
		particle_system_data.start_color,
		particle_system_value_data[ParticleIndex].data.y / particle_system_value_data[ParticleIndex].data.x
	);

	particle_vertex_data[ParticleIndex * 3 + 0].color = color;
	particle_vertex_data[ParticleIndex * 3 + 1].color = color;
	particle_vertex_data[ParticleIndex * 3 + 2].color = color;
}